package gunit

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"testing"

	"github.com/smartystreets/assertions"
)

type Fixture struct{ *T }

func NewFixture(t *testing.T) *Fixture {
	if !validated {
		fmt.Println("Startup validation either failed or was not invoked. Please regenerate test code using the `gunit` command.")
		os.Exit(1)
	}
	return &Fixture{T: NewT(t)}
}

// So is a convenience method for reporting assertion failure messages,
// say from the assertion functions found in github.com/smartystreets/assertions/should.
// Example: self.So(actual, should.Equal, expected)
func (self *Fixture) So(actual interface{}, assert func(actual interface{}, expected ...interface{}) string, expected ...interface{}) {
	if ok, failure := assertions.So(actual, assert, expected...); !ok {
		self.T.Fail()
		self.T.Log("\t" + strings.Replace(failure, "\n", "\n\t\t", -1))
	}
}

func (self *Fixture) Finalize() {
	self.T.finalize()
}

//////////////////////////////////////////////////////////////////////////////

type T struct {
	*testing.T
	log     *bytes.Buffer
	skipped bool
}

func NewT(t *testing.T) *T {
	return &T{T: t, log: &bytes.Buffer{}}
}

func (self *T) finalize() {
	if self.log.Len() > 0 {
		if testing.Verbose() || self.T.Failed() {
			fmt.Println(self.log.String()) // Consider using self.T.Log(self.log.String()) // which will pollute the output with a line number from this file...
		}
	}
	if self.skipped {
		self.T.SkipNow()
	}
}

func (self *T) Error(args ...interface{}) {
	self.Log(args...)
	self.T.Fail()
}
func (self *T) Errorf(message string, args ...interface{}) {
	self.Logf(message, args...)
	self.T.Fail()
}

func (self *T) Skip(args ...interface{}) {
	self.Log(args...)
	self.skipped = true
}
func (self *T) Skipf(message string, args ...interface{}) {
	self.Logf(message, args...)
	self.skipped = true
}

func (self *T) Logf(message string, args ...interface{}) {
	self.log.WriteString("\t" + fmt.Sprintf(message, args...))

}
func (self *T) Log(args ...interface{}) {
	self.log.WriteString("\t" + fmt.Sprintln(args...))
}

//////////////////////////////////////////////////////////////////////////////

// Validate ensures that the generated checksums match the existing *.go files actually on disk.
// If there is a mismatch, os.Exit(>0) is called to signal the problem and prevent tests from running.
// This is simply a measure to prevent well-meaning users from forgetting to regenerate test code
// whenever a *.go file changes. This function is only intended to be called by code generated by
// the command at github.com/smartystreets/gunit/gunit.
func Validate(checksums map[string]string) {
	// _, file, _, _ := runtime.Caller(1)
	// directory := filepath.Base(file)
	// listing, err := ioutil.ReadDir(directory)
	// if len(directory) == 0 || len(generatedListing) == 0 {
	// 	fmt.Fprintf(os.Stdout,
	// 		"Received blank direcory and/or listing values: directory: [%s] listing: [%s]\n",
	// 		directory, generatedListing)
	// 	os.Exit(1)
	// }
	// if err != nil {
	// 	fmt.Fprintf(os.Stdout, "Error reading listing in generated code: [%s]", err.Error())
	// 	os.Exit(1)
	// }

	// TODO: implement the checksum validation function
	// 1. For each file/checksum pair, verify that the file still exists and that the checksum matches the current contents
	// 2. Make sure there are not any additional files.
	// 3. If mismatch, fmt.Println("error!!!!") && os.Exit(1)
	// 4. Set validated flag (for case when user tries to delete the checksums)
	validated = true
}

var validated bool
