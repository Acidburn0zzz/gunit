package gunit

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	"github.com/smartystreets/assertions"
	"github.com/smartystreets/gunit/gunit/generate"
)

type Fixture struct{ *T }

func NewFixture(t *testing.T) *Fixture {
	if !validated {
		exit(1, "Startup validation either failed or was not invoked. Please regenerate test code using the `gunit` command.")
	}
	return &Fixture{T: NewT(t)}
}

// So is a convenience method for reporting assertion failure messages,
// say from the assertion functions found in github.com/smartystreets/assertions/should.
// Example: self.So(actual, should.Equal, expected)
func (self *Fixture) So(actual interface{}, assert func(actual interface{}, expected ...interface{}) string, expected ...interface{}) {
	if ok, failure := assertions.So(actual, assert, expected...); !ok {
		self.T.Fail()
		self.T.Log("\t" + strings.Replace(failure, "\n", "\n\t\t", -1))
	}
}

func (self *Fixture) Finalize() {
	self.T.finalize()
}

//////////////////////////////////////////////////////////////////////////////

type T struct {
	*testing.T
	log     *bytes.Buffer
	skipped bool
}

func NewT(t *testing.T) *T {
	return &T{T: t, log: &bytes.Buffer{}}
}

func (self *T) finalize() {
	if self.log.Len() > 0 && (testing.Verbose() || self.T.Failed()) {
		fmt.Println(self.log.String()) // Consider using self.T.Log(self.log.String()) // which will pollute the output with a line number from this file...
	}
	if self.skipped {
		self.T.SkipNow()
	}
}

func (self *T) Error(args ...interface{}) {
	self.Log(args...)
	self.T.Fail()
}
func (self *T) Errorf(message string, args ...interface{}) {
	self.Logf(message, args...)
	self.T.Fail()
}

func (self *T) Skip(args ...interface{}) {
	self.Log(args...)
	self.skipped = true
}
func (self *T) Skipf(message string, args ...interface{}) {
	self.Logf(message, args...)
	self.skipped = true
}

func (self *T) Logf(message string, args ...interface{}) {
	self.log.WriteString("\t" + fmt.Sprintf(message, args...))

}
func (self *T) Log(args ...interface{}) {
	self.log.WriteString("\t" + fmt.Sprintln(args...))
}

//////////////////////////////////////////////////////////////////////////////

// Validate ensures that the generated checksums match the existing *.go files actually on disk.
// If there is a mismatch, os.Exit(>0) is called to signal the problem and prevent tests from running.
// This is simply a measure to prevent well-meaning users from forgetting to regenerate test code
// whenever a *.go file changes. This function is only intended to be called by code generated by
// the command at github.com/smartystreets/gunit/gunit.
func Validate(checksum int64) {
	_, file, _, _ := runtime.Caller(1)
	directory := filepath.Dir(file)
	listing, err := ioutil.ReadDir(directory)
	if err != nil {
		exit(1, "Could not read the directory ('%s'). Error: %s", directory, err.Error())
	}
	current := generate.Checksum(generate.SelectGoFiles(listing))
	if checksum != current {
		exit(1, "The checksum provided (%d) does not match the current file listing (%d). Please re-run the `gunit` command and try again.", checksum, current)
	}
	validated = true
}

var validated bool

var exit = func(status int, message string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, message, args...)
	os.Exit(status)
}
